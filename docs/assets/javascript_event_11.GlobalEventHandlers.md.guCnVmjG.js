import{_ as e,c as o,o as l,a3 as d}from"./chunks/framework.aC9gkKXW.js";const k=JSON.parse('{"title":"GlobalEventHandlers 接口","description":"","frontmatter":{},"headers":[],"relativePath":"javascript/event/11.GlobalEventHandlers.md","filePath":"javascript/event/11.GlobalEventHandlers.md","lastUpdated":1716973501000}'),i={name:"javascript/event/11.GlobalEventHandlers.md"},c=d('<h1 id="globaleventhandlers-接口" tabindex="-1">GlobalEventHandlers 接口 <a class="header-anchor" href="#globaleventhandlers-接口" aria-label="Permalink to &quot;GlobalEventHandlers 接口&quot;">​</a></h1><p><code>指定事件的回调函数，推荐使用的方法是元素的addEventListener方法。</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, clickHandler, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><code>除了之外，还有一种方法可以直接指定事件的回调函数。</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.onclick </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clickHandler;</span></span></code></pre></div><p><code>这个接口是由GlobalEventHandlers接口提供的。它的优点是使用比较方便，缺点是只能为每个事件指定一个回调函数，并且无法指定事件触发的阶段（捕获阶段还是冒泡阶段）。</code><br><br><code>HTMLElement、Document和Window都继承了这个接口，也就是说，各种 HTML 元素、document对象、window对象上面都可以使用GlobalEventHandlers接口提供的属性。下面就列出这个接口提供的主要的事件属性。</code></p><ul><li><code>GlobalEventHandlers.onabort:某个对象的abort事件（停止加载）发生时，就会调用onabort属性指定的回调函数。</code></li><li><code>GlobalEventHandlers.onerror:error事件发生时，就会调用onerror属性指定的回调函数。</code></li><li><code>GlobalEventHandlers.onload:元素完成加载时，会触发load事件</code></li><li><code>GlobalEventHandlers.onloadstart:对于&lt;img&gt;和&lt;video&gt;等元素，加载开始时还会触发loadstart事件，导致执行onloadstart</code></li><li><code>GlobalEventHandlers.onfocus:当前元素获得焦点时，会触发element.onfocus</code></li><li><code>GlobalEventHandlers.onblur:失去焦点时，会触发element.onblur。</code></li><li><code>GlobalEventHandlers.onscroll:页面或元素滚动时，会触发scroll事件，导致执行onscroll()。</code></li><li><code>GlobalEventHandlers.oncontextmenu:用户在页面上按下鼠标的右键，会触发contextmenu事件，导致执行oncontextmenu()。如果该属性执行后返回false，就等于禁止了右键菜单。</code></li><li><code>GlobalEventHandlers.onshow:元素的右键菜单显示时，会触发该元素的onshow监听函数。</code></li></ul><p><code>鼠标的事件属性。</code></p><ul><li><code>onclick</code></li><li><code>ondblclick</code></li><li><code>onmousedown</code></li><li><code>onmouseenter</code></li><li><code>onmouseleave</code></li><li><code>onmousemove</code></li><li><code>onmouseout</code></li><li><code>onmouseover</code></li><li><code>onmouseup</code></li><li><code>onwheel</code></li></ul><p><code>键盘的事件属性。</code></p><ul><li><code>onkeydown</code></li><li><code>onkeypress</code></li><li><code>onkeyup</code></li></ul><p><code>焦点的事件属性。</code></p><ul><li><code>onblur</code></li><li><code>onfocus</code></li></ul><p><code>表单的事件属性。</code></p><ul><li><code>oninput</code></li><li><code>onchange</code></li><li><code>onsubmit</code></li><li><code>onreset</code></li><li><code>oninvalid</code></li><li><code>onselect</code></li></ul><p><code>触摸的事件属性。</code></p><ul><li><code>ontouchcancel</code></li><li><code>ontouchend</code></li><li><code>ontouchmove</code></li><li><code>ontouchstart</code></li></ul><p><code>拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。</code><br></p><p><code>被拖动元素的事件属性。</code></p><ul><li><code>ondragstart：拖动开始</code></li><li><code>ondrag：拖动过程中，每隔几百毫秒触发一次</code></li><li><code>ondragend：拖动结束</code>+</li></ul><p><code>接收被拖动元素的容器元素的事件属性。</code></p><ul><li><code>ondragenter：被拖动元素进入容器元素。</code></li><li><code>ondragleave：被拖动元素离开容器元素。</code></li><li><code>ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。</code></li><li><code>ondrop：松开鼠标后，被拖动元素放入容器元素。</code></li></ul><p><code>&lt;dialog&gt;对话框元素的事件属性。</code></p><ul><li><code>oncancel</code></li><li><code>onclose</code></li></ul>',24),n=[c];function a(s,t,r,p,h,u){return l(),o("div",null,n)}const E=e(i,[["render",a]]);export{k as __pageData,E as default};
