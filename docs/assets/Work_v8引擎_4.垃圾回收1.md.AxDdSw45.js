import{_ as e,c as o,o as a,a3 as r}from"./chunks/framework.aC9gkKXW.js";const t="/assets/v841.BcofAIBE.jpeg",n="/assets/v842.BA2DiUPU.jpeg",s="/assets/v843.usrwybOE.jpeg",h=JSON.parse('{"title":"垃圾回收算法1","description":"","frontmatter":{},"headers":[],"relativePath":"Work/v8引擎/4.垃圾回收1.md","filePath":"Work/v8引擎/4.垃圾回收1.md","lastUpdated":1716962640000}'),c={name:"Work/v8引擎/4.垃圾回收1.md"},_=r('<h1 id="垃圾回收算法1" tabindex="-1">垃圾回收算法1 <a class="header-anchor" href="#垃圾回收算法1" aria-label="Permalink to &quot;垃圾回收算法1&quot;">​</a></h1><h4 id="scanvenge算法-新生代对象使用的回收算法" tabindex="-1">Scanvenge算法，新生代对象使用的回收算法 <a class="header-anchor" href="#scanvenge算法-新生代对象使用的回收算法" aria-label="Permalink to &quot;Scanvenge算法，新生代对象使用的回收算法&quot;">​</a></h4><p>Scanvenge是一种复制形式的垃圾回收算法，是应用于新生代对象中的一种垃圾回收算法，算法首先将堆内存一分为二，两部分空间一半用来分配赋值的对象，叫做From空间，另一半处于空闲的叫做To空间。<br> 为什么要有一半空间用来闲置呢？这不是让我们的可用内存更小了吗？ 当我们为堆分配对象时，会将分配对象放到From空间中存储，在V8的垃圾和回收过程中，会首先检查From中存活的对象（什么是存活的对象，就是指那些还被继续引用没有完全释放的对象），V8会将From中存活的对象夫妇复制到To空间中，同时清理掉已经被释放的对象空间。完成该过程From空间和To空间即完成了角色对换，也就是在下一次回收中，之前的From空间变成了To空间，之前的To空间变成了From空间。<br> 这样我们来重新定义一下：<br> 用来存放对象的一半是From空间，处于闲置状态的一半是To空间。<br><img src="'+t+'" alt="1"><br> Scanvenge算法明显的缺点就是只能使用堆内存的一半，但是随之带来的好处就是它在时间效率上的优异的表现，属于典型的牺牲空间换取时间的算法。 需要强调的是，开头提到的Scanvenge算法是应用于新生代对象中的一种垃圾回收算法，因为新生代对象中的生命周期较短的特性，也契合于该算法优先时间考虑的特性。 怎样算生命周期较长的对象？<br> 当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种生命周期较长的对象随后会被移动到老生代对象中，采用新的算法（Mark-Sweep&amp;Mark-Compact）进行管理，这个过程称为晋升。<br> 通过上图可以了解到，对象进行垃圾回收是怎样从From到To之间转换的，那么这个晋升的过程在哪儿体现呢？ 在默认情况下，V8对新生代对象进行从From到To空间进行复制时，会先检查它的内存地址来判断这个对象是否已经经历过一次Scanvenge回收。如果已经经历过，那么会将该对象从From空间直接复制到老生代空间，如果没有，才会将其复制到To空间。<br><img src="'+n+'" alt="1"><br> 以上，我们讲述的就是一个新生代对象如何晋升为老生代对象的第一个条件“对象是否经历过Scanvenge回收”，那么第二个条件也许你会更困惑，超出限制？多少算在限制？怎么超出？ 假设一个对象像刚才说的没有经历过Scanvenge回收，要将它复制到To空间之前，还要再进行一次检查。检查To空间是否已经使用了超过25%，如果To空间超过25%，该对象将直接被晋升到老生代空间进行管理。<br> 完整看一下这个流程：<br><img src="'+s+'" alt="1"><br> 对象晋升后，该对象即成为老生代中的存活周期较长的对象，所以我们可以重新对老生代进行定义：老生代对象为存活周期较长或常驻内存的对象，或为新生代对象回收中溢出的对象。 至于为什么设置25%的原因是，当一次Scanvenge回收完成时，To空间变为From空间，如果新的From空间使用占比过高，将对接下来的内存分配到这个新的From空间过程存在很大的影响，因为To空间转换为From空间之后，后面可能会进行多轮的Scanvenge算法进行垃圾回收。</p>',3),m=[_];function i(p,d,l,v,T,g){return a(),o("div",null,m)}const S=e(c,[["render",i]]);export{h as __pageData,S as default};
