import{_ as t,c as e,o as a,a3 as r}from"./chunks/framework.aC9gkKXW.js";const c="/assets/dandianyuanli.D9Rrev2r.png",m=JSON.parse('{"title":"实现原理","description":"","frontmatter":{},"headers":[],"relativePath":"Work/单点登录/2.实现原理.md","filePath":"Work/单点登录/2.实现原理.md","lastUpdated":1716962640000}'),o={name:"Work/单点登录/2.实现原理.md"},i=r('<h1 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h1><p>1.用户首次访问 A 系统，A 系统发现用户未登录，则重定向到 SSO 认证中心并携带请求 url，进行登录验证；</p><p>2.用户在 SSO 认证中心进行用户名和密码验证登录，登录成功后，服务器生成一个 ticket，然后重定向到系统 A 并将该 ticket 追加到 url 参数。</p><p>3.系统 A 获取到 url 参数中的 ticket，向 SSO 发起 ticket 较验，较验成功，则系统 A 放行，并将 ticket 存入到 localStorage。</p><p>4.用户访问 B 系统，此时 B 系统 domain 下已经携带 ticket，直接向 SSO 发起 ticket 较验，较验成功，则放行，并将 ticket 存入 localStorage(更新 ticket 过期时间)</p><p>5.用户登出时，通过退出接口，将ticket置为失效，重定向到 SSO 认证中心并携带请求 url，此时其他系统发出任何接口都将返回ticket失效状态。</p><h5 id="注" tabindex="-1">注 <a class="header-anchor" href="#注" aria-label="Permalink to &quot;注&quot;">​</a></h5><p>SSO系统登录后，跳回原业务系统时，带了个参数ticket，业务系统必须拿ticket再次访问SSO进行验证，否则在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，则会造成不可预估的后果。</p><p><img src="'+c+'" alt="RUNOOB 图标"></p>',9),_=[i];function s(n,l,p,d,S,k){return a(),e("div",null,_)}const u=t(o,[["render",s]]);export{m as __pageData,u as default};
