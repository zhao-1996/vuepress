import{_ as l,c as i,o as e,a3 as o}from"./chunks/framework.BvVpiGod.js";const t="/vuepress/assets/liucheng1.B4hYA3cS.webp",g=JSON.parse('{"title":"整体流程","description":"","frontmatter":{},"headers":[],"relativePath":"tool/依赖管理/7.整体流程.md","filePath":"tool/依赖管理/7.整体流程.md","lastUpdated":1716962640000}'),a={name:"tool/依赖管理/7.整体流程.md"},n=o('<h1 id="整体流程" tabindex="-1">整体流程 <a class="header-anchor" href="#整体流程" aria-label="Permalink to &quot;整体流程&quot;">​</a></h1><p>好了，我们再来整体总结下上面的流程：</p><ul><li>检查 .npmrc 文件：优先级为：项目级的 .npmrc 文件 &gt; 用户级的 .npmrc 文件&gt; 全局级的 .npmrc 文件 &gt; npm 内置的 .npmrc 文件</li><li>检查项目中有无 lock 文件。</li></ul><p>无 lock 文件：</p><ul><li>从 npm 远程仓库获取包信息</li><li>根据 package.json 构建依赖树，构建过程： <ul><li>构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在 node_modules 根目录。</li><li>当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 node_modules 下放置该模块。</li><li>注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包</li></ul></li><li>在缓存中依次查找依赖树中的每个包 <ul><li>不存在缓存： <ul><li>从 npm 远程仓库下载包</li><li>校验包的完整性</li><li>校验不通过： <ul><li>重新下载</li></ul></li><li>校验通过： <ul><li>将下载的包复制到 npm 缓存目录</li><li>将下载的包按照依赖结构解压到 node_modules</li></ul></li></ul></li><li>存在缓存：将缓存按照依赖结构解压到 node_modules <ul><li>将包解压到 node_modules</li><li>生成 lock 文件</li></ul></li></ul></li></ul><p>有 lock 文件：</p><ul><li>检查 package.json 中的依赖版本是否和 package-lock.json 中的依赖有冲突。</li><li>如果没有冲突，直接跳过获取包信息、构建依赖树过程，开始在缓存中查找包信息，后续过程相同</li></ul><p><img src="'+t+'" alt="RUNOOB 图标"><br> 上面的过程简要描述了 npm install 的大概过程，这个过程还包含了一些其他的操作，例如执行你定义的一些生命周期函数，你可以执行 npm install package --timing=true --loglevel=verbose 来查看某个包具体的安装流程和细节。</p>',8),s=[n];function _(c,p,r,u,m,d){return e(),i("div",null,s)}const k=l(a,[["render",_]]);export{g as __pageData,k as default};
