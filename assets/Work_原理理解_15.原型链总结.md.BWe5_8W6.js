import{_ as s,c as i,o as a,a3 as n}from"./chunks/framework.BvVpiGod.js";const d=JSON.parse('{"title":"原型链总结","description":"","frontmatter":{},"headers":[],"relativePath":"Work/原理理解/15.原型链总结.md","filePath":"Work/原理理解/15.原型链总结.md","lastUpdated":1716973501000}'),t={name:"Work/原理理解/15.原型链总结.md"},p=n(`<h1 id="原型链总结" tabindex="-1">原型链总结 <a class="header-anchor" href="#原型链总结" aria-label="Permalink to &quot;原型链总结&quot;">​</a></h1><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">每个函数都有一个 prototype 原型属性，这个属性它是一个指针，指向一个对象，而这个对象的用途是可以由特定类型的所有实例共享的属性和方法。则这个 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">读取对象中的某个属性，JavaScript引擎先寻找对象本身的属性，如果找不到就到它的原型去找，如果还是找不到，就到原型的原型中去找。直到最顶层的Object.prototype时，还是找不到，则返回Undefined。这就是所谓的原型链</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 每创建一个函数，该函数都会自动带有一个prototype属性，这个属性是一个指针，指向一个对象，该对象称为原型对象。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">原型对象上默认有一个属性为constructor，该属性也是一个指针，指向其相关联的构造函数。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">通过调用构造函数产生的实例对象，都有一个内部属性，指向了原型对象，其实例对象能够访问原型对象上的所有属性和方法。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">每个构造函数都有一个原型对象，原型对象上包含着一个指向构造函数的指针，而实例都包含着一个指向原型对象的内部指针。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">实例可以通过内部指针访问到原型对象，原型对象可以通过constructor找到构造函数。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">functions中有prototype，objects中有__proto__，prototype是函数才有的属性，__proto__是每个对象都有的属性，但__proto__不是一个规范属性，只是部分浏览器实现了此属性，对应的标准是[[</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">Prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">大多数情况下，__proto__可以理解为“构造器的原型”，即：__proto__===constructor.prototype。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">__proto__的指向取决于对象创建时的实现方式。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">构造函数实例，封装的函数，如果通过new操作符来调用，就是构造函数，如果没有通过new操作符来调用的，就是普通函数。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">函数Person(对象)有一个属性prototype指针，指向原型对象，Person.prototype原型对象，实质也是对象，它有个属性constructor指针，又指向Person函数对象。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">实例对象person</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">有个属性[[</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">Prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]]（内部属性，chrome和firefix,Safari中这个属性叫__proto__）指向原型对象。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">可以通过实例对象的constructor访问构造函数，可以使用代码person</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.constructor访问构造函数，但是constructor的本质是原型对象上的属性。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">所有对象都有valueOf和toString方法的原因就是从Object.prototype继承的。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">在整个原型链上寻找某个属性，对性能有影响的，越是上层的原型对象，对性能的影响就越大，如果寻找某个不存在的属性，将会遍历整个原型链。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">js中一切都是对象，但是也区分普通对象和函数对象，通过new Function()出来的就是函数对象。普通对象的构造函数就是Object，而函数对象的构造函数就是Function。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Function prototype是一个空函数。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">每个对象都有__proto__属性，但是只有函数对象才有prototype属性。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">\`\`\`</span></span></code></pre></div>`,2),e=[p];function l(o,h,r,E,k,c){return a(),i("div",null,e)}const y=s(t,[["render",l]]);export{d as __pageData,y as default};
