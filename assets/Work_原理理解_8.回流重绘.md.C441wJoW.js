import{_ as a,c as r,o as e,a3 as t}from"./chunks/framework.BvVpiGod.js";const m=JSON.parse('{"title":"回流重绘","description":"","frontmatter":{},"headers":[],"relativePath":"Work/原理理解/8.回流重绘.md","filePath":"Work/原理理解/8.回流重绘.md","lastUpdated":1653028707000}'),o={name:"Work/原理理解/8.回流重绘.md"},i=t('<h1 id="回流重绘" tabindex="-1">回流重绘 <a class="header-anchor" href="#回流重绘" aria-label="Permalink to &quot;回流重绘&quot;">​</a></h1><h4 id="html-加载时发生了什么" tabindex="-1">HTML 加载时发生了什么 <a class="header-anchor" href="#html-加载时发生了什么" aria-label="Permalink to &quot;HTML 加载时发生了什么&quot;">​</a></h4><p>浏览器会把获取到 HTML 代码解析成一个 DOM 树，这个 DOM 包含了所有的<br> HTML 标签，包括属性 display 未 none 的 DOM 元素，属性 visibility 为 hidden<br> 的元素，还有 js 动态添加的元素。<br> 然后浏览器解析 css 代码，对 css 代码中非法语句会直接忽略掉，计算出最终的样式数据<br> 得到 dom 树和最终样式数据之后，浏览器会构建一个渲染树<br> 渲染树是不包含属性 display 为 none 的元素和 head 元素的，<br> 构建渲染树之后，浏览器会将渲染树绘制到屏幕中</p><h4 id="回流" tabindex="-1">回流 <a class="header-anchor" href="#回流" aria-label="Permalink to &quot;回流&quot;">​</a></h4><p>当渲染树中的一部分元素的规模尺寸，布局，位置，隐藏，以及浏览器窗口大小变化等<br> 发生改变需要重新构建，这个过程就称为回流，页面的初始化加载也是回流。<br> 在回流的时候，浏览器会使渲染树中收到影响的部分失效，并重新构建这部分渲染树。<br> 完成回流后，浏览器会重新绘制受影响的部分到屏幕中，这个过程称为重绘。<br> 总之，回流一定触发重绘</p><h4 id="重绘" tabindex="-1">重绘 <a class="header-anchor" href="#重绘" aria-label="Permalink to &quot;重绘&quot;">​</a></h4><p>重绘就是渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，<br> 而不会影响布局，比如 background-color。<br> 更新属性后，浏览器重新绘制元素的外观，风格。这个过程称之为重绘。<br></p><h4 id="回流与重绘的区别" tabindex="-1">回流与重绘的区别 <a class="header-anchor" href="#回流与重绘的区别" aria-label="Permalink to &quot;回流与重绘的区别&quot;">​</a></h4><p>回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流<br> 当页面布局和几何属性改变时就需要回流<br> 比如：添加或者删除的 DOM 元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变等。<br> 所以我们能得知回流的代价一定比重绘高，回流的花销更渲染树有多少节点需要从新构建有关。</p><h4 id="浏览器帮忙优化" tabindex="-1">浏览器帮忙优化 <a class="header-anchor" href="#浏览器帮忙优化" aria-label="Permalink to &quot;浏览器帮忙优化&quot;">​</a></h4><p>因为回流重绘机制的存在，所以浏览器会帮助我们优化这些操作。浏览器会维护一个队列<br> 把所有会引起回流重绘的操作放入这个队列，等队列中的操作到了一定数量或者到了一定时间<br> 浏览器就会清空队列，进行一个批次的处理。这样就会让多次的回流重绘变成一个回流重绘。<br> 也所以，当我们编辑好复杂表单，但是突然去忙别的了，过了一定时间浏览器清空队列，自动的将<br> 网页刷新了，而我们编辑好的数据没进行保存，也将不复存在。</p>',11),n=[i];function s(d,h,l,c,b,_){return e(),r("div",null,n)}const u=a(o,[["render",s]]);export{m as __pageData,u as default};
