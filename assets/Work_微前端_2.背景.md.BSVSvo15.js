import{_ as e,c as a,o,a3 as t}from"./chunks/framework.BvVpiGod.js";const m=JSON.parse('{"title":"背景","description":"","frontmatter":{},"headers":[],"relativePath":"Work/微前端/2.背景.md","filePath":"Work/微前端/2.背景.md","lastUpdated":1650461441000}'),c={name:"Work/微前端/2.背景.md"},r=t('<h1 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h1><p><code>随着这些年互联网的飞速发展，很多企业的web应用在持续迭代中功能越来越复杂，参与的人员、团队不断增多，导致项目出现难以维护的问题，这种情况PC端尤其常见，许多研发团队也在找寻一种高效管理复杂应用的方案，于是微前端被提及的越来越频繁。</code><br><code>微前端并不是一项新的技术，而是一种架构理念，它将单一的web应用拆解成多个可以独立开发、独立运行、独立部署的小型应用，并将它们整合为一个应用。</code><br></p><h4 id="方案对比" tabindex="-1">方案对比 <a class="header-anchor" href="#方案对比" aria-label="Permalink to &quot;方案对比&quot;">​</a></h4><p><b><code>iframe：</code></b><code>在所有微前端方案中，iframe是最稳定的、上手难度最低的，但它有一些无法解决的问题，例如性能低、通信复杂、双滚动条、弹窗无法全局覆盖，它的成长性不高，只适合简单的页面渲染。</code><br><b><code>npm包：</code></b><code>将子应用封装成npm包，通过组件的方式引入，在性能和兼容性上是最优的方案，但却有一个致命的问题就是版本更新，每次版本发布需要通知接入方同步更新，管理非常困难。</code><br><b><code>微前端框架：</code></b><code>流行的微前端框架有single-spa、qiankun、micro-app，它们将维护成本和功能上达到一种平衡，是目前实现微前端备受推崇的方案。</code><br></p>',4),d=[r];function _(n,s,i,p,l,b){return o(),a("div",null,d)}const f=e(c,[["render",_]]);export{m as __pageData,f as default};
