import{_ as e,c as o,o as a,a3 as n}from"./chunks/framework.BvVpiGod.js";const t="/vuepress/assets/weiqianduanjianrong.CEM7TtVK.png",_=JSON.parse('{"title":"方案","description":"","frontmatter":{},"headers":[],"relativePath":"Work/微前端/3.方案.md","filePath":"Work/微前端/3.方案.md","lastUpdated":1716962640000}'),p={name:"Work/微前端/3.方案.md"},r=n('<h1 id="方案" tabindex="-1">方案 <a class="header-anchor" href="#方案" aria-label="Permalink to &quot;方案&quot;">​</a></h1><h4 id="实现思路" tabindex="-1">实现思路 <a class="header-anchor" href="#实现思路" aria-label="Permalink to &quot;实现思路&quot;">​</a></h4><p><code>微前端分为主应用和子应用，主应用也称为基座应用，是其它应用的容器载体，子应用则是被嵌入方。我们分别从主应用和子应用的角度出发，探寻一种更简洁和有效的接入微前端的方式。</code></p><h4 id="微前端的组件化" tabindex="-1">微前端的组件化 <a class="header-anchor" href="#微前端的组件化" aria-label="Permalink to &quot;微前端的组件化&quot;">​</a></h4><p><b><code>HTML Entry：</code></b><code>是指设置html作为资源入口，通过加载远程html，解析其DOM结构从而获取js、css等静态资源来实现微前端的渲染，这也是qiankun目前采用的渲染方案。</code></p><p><b><code>WebComponent：</code></b><code>web原生组件，它有两个核心组成部分：CustomElement和ShadowDom。CustomElement用于创建自定义标签，ShadowDom用于创建阴影DOM，阴影DOM具有天然的样式隔离和元素隔离属性。由于WebComponent是原生组件，它可以在任何框架中使用，理论上是实现微前端最优的方案。但WebComponent有一个无法解决的问题 - ShadowDom的兼容性非常不好，一些前端框架在ShadowDom环境下无法正常运行，尤其是react框架。</code></p><p><b><code>类WebComponent：</code></b><code>就是使用CustomElement结合自定义的ShadowDom实现WebComponent基本一致的功能。</code></p><p><code>由于ShadowDom存在的问题，我们采用自定义的样式隔离和元素隔离实现ShadowDom类似的功能，然后将微前端应用封装在一个CustomElement中，从而模拟实现了一个类WebComponent组件，它的使用方式和兼容性与WebComponent一致，同时也避开了ShadowDom的问题。</code></p><h4 id="micro-app" tabindex="-1">Micro App <a class="header-anchor" href="#micro-app" aria-label="Permalink to &quot;Micro App&quot;">​</a></h4><p><code>基于以上，京东封装了一个自定义标签micro-app，它的渲染机制和功能与WebComponent类似，开发者可以像使用web组件一样接入微前端。它可以兼容任何框架，在使用方式和数据通信上也更加组件化，这显著降低了基座应用的接入成本，并且由于元素隔离的属性，子应用的改动量也大大降低。</code><br><code>并且由于自定义ShadowDom的隔离特性，Micro App不需要像single-spa和qiankun一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改webpack配置。</code><br></p><h4 id="qinkun、single-spa、micro-app" tabindex="-1">qinkun、single-spa、micro-app <a class="header-anchor" href="#qinkun、single-spa、micro-app" aria-label="Permalink to &quot;qinkun、single-spa、micro-app&quot;">​</a></h4><p><code>在single-spa和qiankun中都是通过监听url change事件，在路由变化时匹配到渲染的子应用并进行渲染。这种基于路由监听渲染是single-spa最早实现的，作为出现最早、最有影响力的微前端框架，single-spa被很多框架和公司借鉴，也导致目前实现的微前端的方式大多是基于路由监听。</code><br></p><p><code>同时single-spa要求子应用修改渲染逻辑并暴露出三个方法：bootstrap、mount、unmount，分别对应初始化、渲染和卸载，这也导致子应用需要对入口文件进行修改。这个特点也被qiankun继承下来，并且需要对webpack配置进行一些修改。</code><br></p><p><code>基于路由监听的实现方式和对子应用入口文件以及webpack配置的修改是必须的吗?</code><br><code>其实并不是，微前端的核心在于资源加载与渲染，iframe的渲染方式就是一个典型，只要能够实现一种元素隔离的功能并且路由符合要求，子应用理论上不需要修改代码就可以嵌入另外一个页面渲染</code><br><code>micro-app并没有沿袭single-spa的思路，而是借鉴了WebComponent的思想，通过CustomElement结合自定义的ShadowDom，将微前端封装成一个类WebComponent组件，从而实现微前端的组件化渲染。并且由于自定义ShadowDom的隔离特性，micro-app不需要像single-spa和qiankun一样要求子应用修改渲染逻辑并暴露出方法，也不需要修改webpack配置，是目前市面上接入微前端成本最低的方案。</code><br><br><img src="'+t+'" alt="RUNOOB 图标"></p><p>原理详见<a href="https://cangdu.org/micro-app/docs.html#/" target="_blank" rel="noreferrer">官方文档</a></p>',15),c=[r];function d(s,i,m,l,h,b){return a(),o("div",null,c)}const k=e(p,[["render",d]]);export{_ as __pageData,k as default};
