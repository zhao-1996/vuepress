import{_ as e,c as s,o as t,a3 as a}from"./chunks/framework.BvVpiGod.js";const o="/vuepress/assets/bianpin1.CQ4fSt70.webp",r="/vuepress/assets/bianpin2.D1QyONdX.webp",n="/vuepress/assets/bianpin3.u-ZHW3JD.webp",_="/vuepress/assets/bianpin4.1ei0SRU3.webp",N=JSON.parse('{"title":"扁平结构","description":"","frontmatter":{},"headers":[],"relativePath":"tool/依赖管理/2.扁平结构.md","filePath":"tool/依赖管理/2.扁平结构.md","lastUpdated":1716962640000}'),i={name:"tool/依赖管理/2.扁平结构.md"},p=a('<h1 id="扁平结构" tabindex="-1">扁平结构 <a class="header-anchor" href="#扁平结构" aria-label="Permalink to &quot;扁平结构&quot;">​</a></h1><p>解决以上问题，NPM 在 3.x 版本做了一次较大更新。其将早期的嵌套结构改为扁平结构 安装模块时，不管其是直接依赖还是子依赖的依赖，优先将其安装在 node_modules 根目录<br> 在执行 npm install 后将得到下面的目录结构： <img src="'+o+'" alt="RUNOOB 图标"> 我们若在模块中又依赖了 base64-js@1.0.1 版本：当安装到相同模块时，判断已安装的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 node_modules 下安装该模块。<br> 我们在执行 npm install 后将得到下面的目录结构： <img src="'+r+'" alt="RUNOOB 图标"> 所以 npm 3.x 版本并未完全解决老版本的模块冗余问题，甚至还会带来新的问题。 试想一下，你的APP假设没有依赖 base64-js@1.0.1 版本，而你同时依赖了依赖不同 base64-js 版本的 buffer 和 buffer2。由于在执行 npm install 的时候，按照 package.json 里依赖的顺序依次解析，则 buffer 和 buffer2 在 package.json 的放置顺序则决定了 node_modules 的依赖结构：<br> 先依赖buffer2<br><img src="'+n+'" alt="RUNOOB 图标"><br> 先依赖buffer：<br><img src="'+_+'" alt="RUNOOB 图标"> 另外，为了让开发者在安全的前提下使用最新的依赖包，我们在 package.json 通常只会锁定大版本，这意味着在某些依赖包小版本更新后，同样可能造成依赖结构的改动，依赖结构的不确定性可能会给程序带来不可预知的问题。</p>',2),c=[p];function l(b,d,m,f,u,h){return t(),s("div",null,c)}const g=e(i,[["render",l]]);export{N as __pageData,g as default};
