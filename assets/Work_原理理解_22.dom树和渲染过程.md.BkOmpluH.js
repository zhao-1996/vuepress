import{_ as t,c as a,o as d,j as e,a as o}from"./chunks/framework.BvVpiGod.js";const f=JSON.parse('{"title":"dom树和渲染过程","description":"","frontmatter":{},"headers":[],"relativePath":"Work/原理理解/22.dom树和渲染过程.md","filePath":"Work/原理理解/22.dom树和渲染过程.md","lastUpdated":1654695661000}'),s={name:"Work/原理理解/22.dom树和渲染过程.md"},r=e("h1",{id:"dom树和渲染过程",tabindex:"-1"},[o("dom树和渲染过程 "),e("a",{class:"header-anchor",href:"#dom树和渲染过程","aria-label":'Permalink to "dom树和渲染过程"'},"​")],-1),m=e("p",null,[o("dom渲染流程： 1、浏览器解析html源码，然后创建一个DOM树。 在DOM树中，每一个HTML标签都有一个对应的节点 (元素节点),并且每一个文本也都有一个对应的节点(文本节点)。 DOM树的根节点就是documentElement，对应的是html标签。"),e("br"),o(" 2、浏览器解析CSS代码，计算出最终的样式数据。 对CSS代码中非法的语法它会直接忽略掉。解析CSS 的时候会按照如下顺序来定义优先级：浏览器默认 设置，用户设置，外联样式，内联样式，html中的 style(嵌在标签中的行间样式)。"),e("br"),o(" 3、创建完DOM树并得到最终的样式数据之后，构建一个渲染树。 渲染树和DOM树有点像，但是有区别。DOM树完全和html标签 一一对应，而渲染树会忽略不需要渲染的元素(head、display:none的元素)。 渲染树中每一个节点都存储着对应的CSS属性。"),e("br"),o(" 4、当渲染树创建完成之后，浏览器就可以根据渲染树直接把 页面绘制到屏幕上。 "),e("br"),o(" 渲染树和Dom树的关系"),e("br"),o(" 渲染对象和Dom元素相对应，但这种对应关系不是一对一的， 不可见的Dom元素不会被插入渲染树，例如head元素。另外， display属性为none的元素也不会在渲染树中出现（visibility属性为hidden 的元素将出现在渲染树中）。"),e("br"),o(" 还有一些Dom元素对应几个可见对象，它们一般是一些具有复杂结构的 元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个 显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而折行时， 新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的html， 根据css规范，一个行内元素只能仅包含行内元素或仅包含块状元素， 在存在混合内容时，将会创建匿名的块状渲染对象包裹住行内元素。 一些渲染对象和所对应的Dom节点不在树上相同的位置，例如， 浮动和绝对定位的元素在文本流之外，在两棵树上的位置不同， 渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。")],-1),n=[r,m];function l(c,_,i,h,p,D){return d(),a("div",null,n)}const S=t(s,[["render",l]]);export{f as __pageData,S as default};
