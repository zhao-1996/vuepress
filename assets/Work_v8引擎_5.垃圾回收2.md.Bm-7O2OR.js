import{_ as a,c as r,o as e,a3 as t}from"./chunks/framework.BvVpiGod.js";const s="/vuepress/assets/v851.DGFOQGep.png",o="/vuepress/assets/v852.DQyZP0y0.png",p="/vuepress/assets/v853.AFciYkSL.png",c="/vuepress/assets/v854.BpDtzuMC.png",u=JSON.parse('{"title":"垃圾回收算法2","description":"","frontmatter":{},"headers":[],"relativePath":"Work/v8引擎/5.垃圾回收2.md","filePath":"Work/v8引擎/5.垃圾回收2.md","lastUpdated":1716962640000}'),n={name:"Work/v8引擎/5.垃圾回收2.md"},m=t('<h1 id="垃圾回收算法2" tabindex="-1">垃圾回收算法2 <a class="header-anchor" href="#垃圾回收算法2" aria-label="Permalink to &quot;垃圾回收算法2&quot;">​</a></h1><h4 id="mark-sweep-mark-compact算法-新生代对象使用的回收算法" tabindex="-1">Mark-Sweep&amp;Mark-Compact算法，新生代对象使用的回收算法 <a class="header-anchor" href="#mark-sweep-mark-compact算法-新生代对象使用的回收算法" aria-label="Permalink to &quot;Mark-Sweep&amp;Mark-Compact算法，新生代对象使用的回收算法&quot;">​</a></h4><p>接下来，讲一下老生代中的对象使用的回收算法，这种算法（Mark-Sweep）也是我们常说的垃圾回收中的标记清除算法。<br> 首先，老生代空间不会一分为二，老生代空间进行垃圾回收时，首先是标记阶段。V8会在标记阶段遍历老生代空间中的所有对象，并标记存活的对象（即还没有被完全释放的对象），在随后的清除阶段，会将所有未标记的老生代对象全部回收。 再来张图：<br><img src="'+s+'" alt="1"><br> 如果你稍微有点强迫症，你就发现这张图有点问题。Mark-Sweep在执行完清除之后，导致内存空间出现不连续的情况，就像你的磁盘分析图一样。 这样会带来的一个问题就是，当你需要分配一个较大的对象时，剩余的内存因为碎片化的原因，没有任何一个内存碎片足以分配给这个大的对象内存空间，就会导致提前触发垃圾回收，而这次回收是不必要的。 所以Mark-Compact算法随之而生，Mark-Compact比Mark-Sweep增加了一个整理的概念，它的回收执行顺序是标记—整理—清除。Mark-Compact所谓的整理概念是指在对象同样被标记为存活后，会将活着的对象往一端移动，移动完成后在直接清理掉死亡的对象内存。<br> 不要晕，来张图，你就可以的：<br><img src="'+o+'" alt="1"><br> 两种差别显而易见，Mark-Compact算法执行后的内存空间更合理。但是因为Mark-Compact算法需要移动对象，随之导致的就是它的执行速度没有Mark-Sweep快。<br> 所以在V8中主要使用Mark-Sweep算法，只有在空间不足以对新生代中晋升过来的对象进行分配时，才会使用Mark-Compact算法进行回收。<br><img src="'+p+'" alt="1"><br> Incremental Marking算法<br> 因为垃圾回收会阻塞javascript的运行，故此老生代对象又因为其占用空间大，存活对象多的特点，对其进行标记，整理，回收的过程引起的阻塞要远远比新生代对象回收过程一起的阻塞要严重的多，Incremental Marking算法成为了优化老生代对象耗时的算法选择。<br> 为了降低老生代空间垃圾回收带来的停顿影响，V8 采用了增量标记（incremental marking）的算法。将原本一口气停顿完成的来及回收过程拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑继续执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成，即一一段代码标记完成，先执行下一段代码，在标记，在执行代码......知道所有标记完成，然后执行垃圾回收。取得的效果就是，将老生代空间垃圾回收的最大停顿时间可以减少到原本的1/6左右。<br> 有点晕，不要怕，咱有图：<br><img src="'+c+'" alt="1"><br> V8 后续还引入了延迟清理（lazy sweeping）、增量式整理（incremental compaction）、并发标记 等技术</p>',3),_=[m];function i(k,l,d,b,M,h){return e(),r("div",null,_)}const S=a(n,[["render",i]]);export{u as __pageData,S as default};
