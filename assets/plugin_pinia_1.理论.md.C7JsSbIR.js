import{_ as e,c as a,o as i,a3 as t}from"./chunks/framework.BvVpiGod.js";const _=JSON.parse('{"title":"理论","description":"","frontmatter":{},"headers":[],"relativePath":"plugin/pinia/1.理论.md","filePath":"plugin/pinia/1.理论.md","lastUpdated":1717665040000}'),r={name:"plugin/pinia/1.理论.md"},o=t('<h1 id="理论" tabindex="-1">理论 <a class="header-anchor" href="#理论" aria-label="Permalink to &quot;理论&quot;">​</a></h1><p><a href="https://pinia.vuejs.org/zh/" target="_blank" rel="noreferrer">官网⛷</a></p><h4 id="为什么你应该使用-pinia" tabindex="-1">为什么你应该使用 Pinia <a class="header-anchor" href="#为什么你应该使用-pinia" aria-label="Permalink to &quot;为什么你应该使用 Pinia&quot;">​</a></h4><p>Pinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。如果你熟悉组合式 API 的话，你可能会认为可以通过一行简单的 export const state = reactive({}) 来共享一个全局状态。对于单页应用来说确实可以，但如果应用在服务器端渲染，这可能会使你的应用暴露出一些安全漏洞。</p><h4 id="为什么取名-pinia" tabindex="-1">为什么取名 Pinia <a class="header-anchor" href="#为什么取名-pinia" aria-label="Permalink to &quot;为什么取名 Pinia&quot;">​</a></h4><p>Pinia (发音为 <code>/piːnjʌ/</code>，类似英文中的 <code>“peenya”</code>) 是最接近有效包名 piña (西班牙语中的 pineapple，即“菠萝”) 的词。 菠萝花实际上是一组各自独立的花朵，它们结合在一起，由此形成一个多重的水果。 与 Store 类似，每一个都是独立诞生的，但最终它们都是相互联系的。 它(菠萝)也是一种原产于南美洲的美味热带水果。</p><h4 id="对比-vuex" tabindex="-1">对比 Vuex <a class="header-anchor" href="#对比-vuex" aria-label="Permalink to &quot;对比 Vuex&quot;">​</a></h4><p>Pinia 起源于一次探索 Vuex 下一个迭代的实验，因此结合了 Vuex 5 核心团队讨论中的许多想法。最后，我们意识到 Pinia 已经实现了我们在 Vuex 5 中想要的大部分功能，所以决定将其作为新的推荐方案来代替 Vuex。</p><p>与 Vuex 相比，Pinia 不仅提供了一个更简单的 API，也提供了符合组合式 API 风格的 API，最重要的是，搭配 TypeScript 一起使用时有非常可靠的类型推断支持。</p><h4 id="对比-vuex-3-x-4-x" tabindex="-1">对比 Vuex 3.x/4.x <a class="header-anchor" href="#对比-vuex-3-x-4-x" aria-label="Permalink to &quot;对比 Vuex 3.x/4.x&quot;">​</a></h4><p><code>Vuex 3.x 只适配 Vue 2，而 Vuex 4.x 是适配 Vue 3 的。</code><br> Pinia API 与 Vuex(&lt;=4) 也有很多不同，即：</p><ul><li>mutation 已被弃用。它们经常被认为是极其冗余的。它们初衷是带来 devtools 的集成方案，但这已不再是一个问题了。</li><li>无需要创建自定义的复杂包装器来支持 TypeScript，一切都可标注类型，API 的设计方式是尽可能地利用 TS 类型推理。</li><li>无过多的魔法字符串注入，只需要导入函数并调用它们，然后享受自动补全的乐趣就好。</li><li>无需要动态添加 Store，它们默认都是动态的，甚至你可能都不会注意到这点。注意，你仍然可以在任何时候手动使用一个 Store 来注册它，但因为它是自动- 的，所以你不需要担心它。</li><li>不再有嵌套结构的模块。你仍然可以通过导入和使用另一个 Store 来隐含地嵌套 stores 空间。虽然 Pinia 从设计上提供的是一个扁平的结构，但仍然能够在 Store 之间进行交叉组合。你甚至可以让 Stores 有循环依赖关系。</li><li>不再有可命名的模块。考虑到 Store 的扁平架构，Store 的命名取决于它们的定义方式，你甚至可以说所有 Store 都应该命名。</li></ul>',12),n=[o];function l(p,u,s,c,d,x){return i(),a("div",null,n)}const P=e(r,[["render",l]]);export{_ as __pageData,P as default};
