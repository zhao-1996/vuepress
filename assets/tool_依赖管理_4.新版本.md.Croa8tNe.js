import{_ as o,c as s,o as t,j as e,a}from"./chunks/framework.BvVpiGod.js";const n="/vuepress/assets/bianpin2.D1QyONdX.webp",j=JSON.parse('{"title":"新版本","description":"","frontmatter":{},"headers":[],"relativePath":"tool/依赖管理/4.新版本.md","filePath":"tool/依赖管理/4.新版本.md","lastUpdated":1716962640000}'),c={name:"tool/依赖管理/4.新版本.md"},l=e("h1",{id:"新版本",tabindex:"-1"},[a("新版本 "),e("a",{class:"header-anchor",href:"#新版本","aria-label":'Permalink to "新版本"'},"​")],-1),r=e("p",null,[a("回顾下上面的依赖关系："),e("br"),e("img",{src:n,alt:"RUNOOB 图标"}),e("br"),a(" base64-js@1.0.1 版本与 buffer 中依赖的 base64-js@^1.0.2 发生冲突，所以 base64-js@1.0.1 需要安装在 buffer 包的 node_modules 中，对应了 package-lock.json 中 buffer 的 dependencies 属性。这也对应了 npm 对依赖的扁平化处理方式。 所以，根据上面的分析， package-lock.json 文件 和 node_modules 目录结构是一一对应的，即项目目录下存在 package-lock.json 可以让每次安装生成的依赖目录结构保持相同。")],-1),p=e("p",null,"另外，项目中使用了 package-lock.json 可以显著加速依赖安装时间。 npm i --timing=true --loglevel=verbose 命令可以看到 npm install 的完整过程 package-lock.json 中已经缓存了每个包的具体版本和下载链接，不需要再去远程仓库进行查询，然后直接进入文件完整性校验环节，减少了大量网络请求",-1),_=e("p",null,"开发系统应用时，建议把 package-lock.json 文件提交到代码版本仓库，从而保证所有团队开发者以及 CI 环节可以在执行 npm install 时安装的依赖版本都是一致的。 在开发一个 npm包 时，你的 npm包 是需要被其他仓库依赖的，由于上面我们讲到的扁平安装机制，如果你锁定了依赖包版本，你的依赖包就不能和其他依赖包共享同一 semver 范围内的依赖包，这样会造成不必要的冗余。所以我们不应该把package-lock.json 文件发布出去（ npm 默认也不会把 package-lock.json 文件发布出去）。",-1),d=[l,r,p,_];function i(m,k,f,u,b,h){return t(),s("div",null,d)}const v=o(c,[["render",i]]);export{j as __pageData,v as default};
