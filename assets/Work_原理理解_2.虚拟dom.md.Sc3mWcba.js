import{_ as r,c as e,o as a,a3 as t}from"./chunks/framework.BvVpiGod.js";const f=JSON.parse('{"title":"虚拟dom","description":"","frontmatter":{},"headers":[],"relativePath":"Work/原理理解/2.虚拟dom.md","filePath":"Work/原理理解/2.虚拟dom.md","lastUpdated":1652184936000}'),o={name:"Work/原理理解/2.虚拟dom.md"},d=t('<h1 id="虚拟dom" tabindex="-1">虚拟dom <a class="header-anchor" href="#虚拟dom" aria-label="Permalink to &quot;虚拟dom&quot;">​</a></h1><p>虚拟domVirtual DOM 其实就是一棵以虚拟节点（VNode）作为基础的树 最终可以通过一系列操作使这棵树映射到真实DOM树上。可以把Virtual DOM 理解为 一个简单的JS对象，它包含标签名、属性和子元素三个属性。</p><h4 id="dom操作成本" tabindex="-1">dom操作成本 <a class="header-anchor" href="#dom操作成本" aria-label="Permalink to &quot;dom操作成本&quot;">​</a></h4><p>操作DOM具体的成本，说到底是造成浏览器回流reflow和重绘reflow，从而消耗GPU资源。<br> 因为增删改dom通常都会触发回流，除非只是改颜色或者字体，就连改HTML元素尺寸、字体大小发生变化都需要重新构建dom树<br> 从而触发回流<br> 现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。</p><p>引起reflow回流<br> 页面第一次渲染（初始化）<br> DOM树变化（如：增删节点）<br> Render树变化（如：padding改变）<br> 浏览器窗口resize<br> 获取元素的某些属性：<br> 浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括offsetLeft、<br> offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height、<br> 调用了getComputedStyle()或者IE的currentStyle</p><p>repaint重绘<br> reflow回流必定引起repaint重绘，重绘可以单独触发<br> 背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）</p><h4 id="原生-dom-操作-通过框架封装操作。" tabindex="-1">原生 DOM 操作 / 通过框架封装操作。 <a class="header-anchor" href="#原生-dom-操作-通过框架封装操作。" aria-label="Permalink to &quot;原生 DOM 操作 / 通过框架封装操作。&quot;">​</a></h4><p>这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，<br> 让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何<br> 框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何<br> 上层 API 可能产生的操作，它的实现必须是普适的。</p><h4 id="virtual-dom-innerhtml" tabindex="-1">Virtual DOM / innerHTML <a class="header-anchor" href="#virtual-dom-innerhtml" aria-label="Permalink to &quot;Virtual DOM / innerHTML&quot;">​</a></h4><p>很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML <br> 其实是一个还算合理的操作... 真正的问题是在 “全部重新渲染” 的思维模式下，<br> 即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。<br> innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)<br> Virtual DOM： render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)<br> Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，<br> 比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算<br> 还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面<br> 大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其<br> 便宜的。这才是为什么要有 Virtual DOM：它保证了 <br> 1.不管你的数据变化多少，每次重绘的性能都可以接受；<br> 2.你依然可以用类似 innerHTML 的思路去写你的应用。</p><h4 id="虚拟dom的优势" tabindex="-1">虚拟dom的优势 <a class="header-anchor" href="#虚拟dom的优势" aria-label="Permalink to &quot;虚拟dom的优势&quot;">​</a></h4><p>在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。<br> 不要天真地以为 Virtual DOM 就是快，diff计算也是需要消耗性能的，batching（将多个状态更新组合为单个新渲染，以获得更好的性能） 么 MVVM 也能做，<br> 而且最终更新dom的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都<br> 不是性能，而是它为函数式的 UI 编程方式打开了大门；</p><h4 id="vue2虚拟dom" tabindex="-1">vue2虚拟dom <a class="header-anchor" href="#vue2虚拟dom" aria-label="Permalink to &quot;vue2虚拟dom&quot;">​</a></h4><p>vue2的虚拟dom是使用diff算法基于整个虚拟节点树状结构的遍历对比<br> 来实现dom更新的，虽然js做这些事情很快，但是在一个大型应用中，<br> 不可避免的会影响性能</p><h4 id="vue3虚拟dom" tabindex="-1">vue3虚拟dom <a class="header-anchor" href="#vue3虚拟dom" aria-label="Permalink to &quot;vue3虚拟dom&quot;">​</a></h4><p>vue3在编译时对需要追踪的节点添加oatchFlag<br> PatchFlag 是Vue在运行时生成的，用作节点标记<br> 只有带PatchFlag的这些node会被真正的追踪，也就是说在后续更新的过程中，<br> Vue会知道静态节点不用管，只需要追踪带有PatchFlag的节点<br> PatchFlag的值为1，注释/* Text */，表示只需关注该节点的文字变化，不用管属性或者其他绑定的变化<br> 无论节点的嵌套层级有多深，动态节点都是直接与Block根节点直接绑定的，<br> 也就是说当diff算法走到了根节点的时候，就会直接跳到动态变化的节点，无需遍历静态节点。<br> 优化前，在一个默认的Virtual Dom的diff中，需要遍历所有节点，而且每一个节点都要比较旧<br> 的props和新的props有没有变化，虽然js做这些事情很快，但是在一个大型应用中，不可避免的会影响性能<br> 而优化之后，diff算法看到一个Block就只需要看里面有没有动态变化的东西，只需要追踪这些就可以了<br> 优化之后，在动态更新时编译器永远只会关注真正会变的东西，既跳出了Virtual Dom 更新性能<br> 瓶颈，又保留了可以手写render function的灵活性。</p>',16),i=[d];function l(n,m,b,h,s,u){return a(),e("div",null,i)}const p=r(o,[["render",l]]);export{f as __pageData,p as default};
